// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package repo

import (
	"context"
)

// iteratorForCreateCrews implements pgx.CopyFromSource.
type iteratorForCreateCrews struct {
	rows                 []string
	skippedFirstNextCall bool
}

func (r *iteratorForCreateCrews) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateCrews) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0],
	}, nil
}

func (r iteratorForCreateCrews) Err() error {
	return nil
}

func (q *Queries) CreateCrews(ctx context.Context, name []string) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"crews"}, []string{"name"}, &iteratorForCreateCrews{rows: name})
}

// iteratorForCreateEarnings implements pgx.CopyFromSource.
type iteratorForCreateEarnings struct {
	rows                 []CreateEarningsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateEarnings) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateEarnings) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].Amount,
		r.rows[0].DateOfWork,
		r.rows[0].PayrollID,
		r.rows[0].WorkerID,
		r.rows[0].CrewID,
	}, nil
}

func (r iteratorForCreateEarnings) Err() error {
	return nil
}

func (q *Queries) CreateEarnings(ctx context.Context, arg []CreateEarningsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"earnings"}, []string{"amount", "date_of_work", "payroll_id", "worker_id", "crew_id"}, &iteratorForCreateEarnings{rows: arg})
}

// iteratorForCreatePayrolls implements pgx.CopyFromSource.
type iteratorForCreatePayrolls struct {
	rows                 []CreatePayrollsParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreatePayrolls) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreatePayrolls) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].PayPeriod,
		r.rows[0].PeriodStart,
		r.rows[0].PeriodEnd,
	}, nil
}

func (r iteratorForCreatePayrolls) Err() error {
	return nil
}

func (q *Queries) CreatePayrolls(ctx context.Context, arg []CreatePayrollsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"payrolls"}, []string{"pay_period", "period_start", "period_end"}, &iteratorForCreatePayrolls{rows: arg})
}

// iteratorForCreateWorkers implements pgx.CopyFromSource.
type iteratorForCreateWorkers struct {
	rows                 []CreateWorkersParams
	skippedFirstNextCall bool
}

func (r *iteratorForCreateWorkers) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForCreateWorkers) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].FirstName,
		r.rows[0].LastName,
	}, nil
}

func (r iteratorForCreateWorkers) Err() error {
	return nil
}

func (q *Queries) CreateWorkers(ctx context.Context, arg []CreateWorkersParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"workers"}, []string{"first_name", "last_name"}, &iteratorForCreateWorkers{rows: arg})
}
